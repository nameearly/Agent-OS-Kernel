# Agent OS Kernel 宣言

> 本文深受 [冯若航](https://vonng.com/db/agent-os/) 的《AI Agent 的操作系统时刻》启发，试图将文章中的理念转化为具体的系统实现。

---

## 一、核心理念：为什么 Agent 需要操作系统？

2025 年，编程 Agent 大爆发。Claude Code、Manus 等产品展示了 AI Agent 的惊人能力。但仔细观察，你会发现一个惊人的事实：**它们的底层操作极其 "原始"**。

Agent 直接操作文件系统和终端，依赖"信任模型"而非"隔离模型"。这就像早期程序可以随意覆写任何内存地址一样——系统的安全边界，取决于程序员的自觉。

这让我想起了 **1980 年代的 DOS**。

DOS 也能用——你可以在上面写程序、编辑文档、玩游戏。但它缺乏现代操作系统的一切：没有内存保护，没有多任务，没有标准化的设备接口。每个应用都直接操作硬件，程序员要自己处理所有底层细节。

**现在，AI Agent 正站在同一个起点。**

---

## 二、核心框架：Agent OS 的五大子系统

在传统计算机中，CPU 是算力来源，RAM 是临时存储，磁盘是持久存储。在 Agent 世界中，我们可以找到精确的对应：

| 传统计算机 | Agent 世界 | 操作系统子系统 |
|-----------|-----------|--------------|
| **CPU** | **LLM** | 进程调度、任务编排 |
| **RAM** | **Context Window** | 内存管理、上下文工程 |
| **Disk** | **Database** | 文件系统、状态持久化 |
| **Device** | **Tools/MCP** | I/O 管理、设备驱动 |
| **Security** | **Sandbox/Observability** | 安全子系统、审计日志 |

Agent OS Kernel 正是围绕这五大子系统构建的。

---

## 三、内存管理：最复杂也最重要的战场

### 3.1 历史的教训：640KB 够用吗？

1981 年，IBM PC 的设计者们认为 640KB 内存"应该够用了"。这成为计算机历史上最著名的错误预言。

今天，当我们说 128K 上下文"已经很大了"时，正在犯同样的错误。

**上下文窗口（Context Window）是 LLM 最稀缺的资源。** 128K tokens 看起来很大，但考虑到各种开销：系统提示词 10-20K，工具定义 10-20K，上下文文档 50-80K……留给实际对话的空间可能只剩小几十K。

### 3.2 虚拟内存：操作系统的革命性创新

回顾操作系统历史，虚拟内存是 Unix 最重要的创新之一。

在虚拟内存出现之前，程序员必须自己管理物理内存分配。如果程序需要的内存超过物理内存，就只能崩溃或手动实现复杂的换入换出逻辑。虚拟内存改变了这一切——它给每个程序一个"幻觉"，好像它拥有整个地址空间。操作系统在背后自动处理页面置换，把不常用的数据换出到磁盘，需要时再换入。

**Agent OS Kernel 的 Context Manager 正是这样的虚拟内存实现：**

- **上下文页面（Page）**：将长上下文分割为固定大小的页面
- **缺页中断（Page Fault）**：访问不在内存中的页面时自动从数据库加载
- **页面置换（Page Replacement）**：LRU + 重要性 + 语义相似度多因素评分
- **KV-Cache 优化**：静态内容前置，动态内容按访问频率排序

### 3.3 Manus 的启示：KV-Cache 命中率是最重要的指标

Manus 团队总结出几个关键实践：

**KV-Cache 命中率是最重要的指标。** 缓存命中 ≈ 模型不用重复"重新读一遍整本书"。在 Claude 上，缓存命中的 token 成本是未命中的 1/10。

Agent OS Kernel 实现了这些最佳实践：

- **静态内容前置**：系统提示、工具定义放在最前面（最可能命中缓存）
- **动态内容排序**：按变化频率排序，变化少的放前面
- **命中率预估**：预估缓存命中率，指导上下文重组

### 3.4 内存层次结构

DeepSeek 的 Engram 论文提供了一个关键视角：存储层次结构。

**Agent 不应该把所有信息都塞进 Context（全放 RAM），也不应该完全依赖外部检索（全放磁盘），而是需要一个智能的分层架构。**

Agent OS Kernel 实现了这种分层：

```
L1 Cache (寄存器)  ->  System Prompt (< 1K tokens, 始终在 context)
L2 Cache (高速缓存) ->  Working Memory (10-20K tokens, 当前任务相关)
RAM (内存)          ->  Session Context (50-100K tokens, 本次会话)
Disk (磁盘)         ->  Long-term Memory (数据库, 无限容量)
```

---

## 四、外存（数据库）：确定性最高的机会

### 4.1 PostgreSQL 的五重角色

当我们讨论内存管理时，一个自然的问题浮现：**换出去的数据存在哪里？**

最终的答案一定是**数据库**。如果说 Context Engineering 是最复杂的技术战场，那么数据库则是确定性最高的商业机会。

PostgreSQL 在 Agent 架构中要扮演五重角色：

| 角色 | 功能 | 类比 |
|-----|------|------|
| **长期记忆存储** | 对话历史、学到的知识、用户偏好 | 海马体 |
| **状态持久化** | Checkpoint/快照、任务状态、恢复点 | 硬盘 |
| **向量索引** | 语义检索、相似度匹配、Context 换入决策 | 页表 |
| **协调服务** | 分布式锁、任务队列、事件通知 | IPC 机制 |
| **审计日志** | 所有操作的不可篡改记录、合规、可重放 | 黑匣子 |

Agent OS Kernel 使用 PostgreSQL 作为核心存储，同时承担这五重角色。

### 4.2 Database as Runtime

一种更激进、更有趣的可能性是：**PostgreSQL 不只扮演存储，而成为 Runtime 本身。**

PostgreSQL 极致的可扩展性与繁荣的扩展生态，让它已经具备了一个完整 Runtime 所需的几乎所有原语。

Agent OS Kernel 正在探索这个方向。

---

## 五、进程管理：表面红海，深水无人

### 5.1 当前的 Agent 框架本质

当前所有 Agent 框架的核心，几乎都是同一个 while loop：

```python
while not done:
    thought = llm.think(context)
    action = llm.decide(thought)
    result = tools.execute(action)
    context.update(result)
```

Think -> Act -> Observe -> Repeat。LangGraph、CrewAI、AutoGen …… 剥开花哨的外衣，内核惊人地相似。

**当核心抽象简单到任何本科生都能实现时，它就不可能成为护城河。**

### 5.2 真正的进程管理

如果认真用操作系统来类比，进程管理远不止一个 while loop。它至少包括：

- **并发调度**：多个 Agent 同时运行，谁先用 GPU？谁先调 API？资源如何分配？
- **状态持久化**：Agent 跑到一半崩了，怎么从断点恢复？
- **进程间通信**：Agent A 的输出要传给 Agent B，用什么协议？共享状态怎么同步？
- **优雅终止**：怎么让 Agent "安全退出"而不是直接 kill -9？

Agent OS Kernel 的 Scheduler 正是为解决这些问题而设计的。

---

## 六、I/O 管理：协议之争的表象与本质

### 6.1 MCP 的问题

MCP 在采用度上取得了巨大成功，但从架构视角看，它可能走了弯路：

- **Token 开销惊人**：MCP 服务器仅工具元数据就可能消耗上万 tokens
- **重新发明轮子**：MCP 试图解决的"工具发现、调用、组合"问题，Unix CLI 已经优雅地做了 55 年

### 6.2 CLI 的优势

CLI 的优势被严重低估了。所有前沿模型都在海量的 CLI 文档、man pages、Stack Overflow 上训练过。

当你让 Claude 用 grep、psql、curl，它几乎不需要额外的 Schema 定义——这些工具的用法已经"内化"在模型权重里了。

更重要的是，CLI 天然符合 Unix 哲学：文本流、管道组合、单一职责。这正是 Agent 需要的可组合性。

### 6.3 Agent-Native CLI

Agent OS Kernel 的判断是：**最终的赢家不会是 MCP，也不会是裸 CLI，而是 "Agent-Native CLI"** —— 输出结构化、错误码标准化、自带发现机制的命令行工具。

设想一下：每个命令都有 --json 输出选项，错误码遵循统一的语义（如 HTTP 状态码），自带 --desc 参数输出机器可读的能力描述。

Agent OS Kernel 的 Tool 系统正是朝这个方向设计的。

---

## 七、安全与可观测性：信任基础设施

### 7.1 Prompt Injection：AI 时代的 Buffer Overflow

当前 Agent 生态最大的安全隐患是 Prompt Injection——但这只是冰山一角。

**Prompt Injection 是 AI 时代的 Buffer Overflow。**

传统的缓冲区溢出是因为程序没有区分 "指令" 和 "数据"，攻击者可以在数据区写入指令让 CPU 执行。Prompt Injection 本质上是同样的问题：LLM 没有在架构层面区分 "System Prompt（指令）" 和 "User Input（数据）"。

这个类比揭示了一个残酷的现实：Buffer Overflow 花了几十年才有了硬件级别的缓解方案（NX bit、ASLR、Stack Canary）。Prompt Injection 目前没有任何架构级别的解决方案。

### 7.2 沙箱是必要的，但远远不够

沙箱的逻辑是"即使 Agent 被骗了，它也造不成太大伤害"。这是对的，但它解决的是"限制能力"，而不是"理解行为"。

**这就是为什么可观测性可能比沙箱更重要。**

### 7.3 真正的信任需要三层基础设施

| 层次 | 功能 | 类比 |
|-----|------|------|
| **沙箱** | 限制 Agent 能做什么 | 监狱的围墙 |
| **可观测性** | 理解 Agent 在做什么、为什么这么做 | 监控摄像头 |
| **审计日志** | 事后追溯完整决策链路 | 飞机黑匣子 |

可观测性的核心是 **"决策溯源"**：Agent 看到了什么输入？它的 reasoning 过程是什么？它为什么选择了这个 action 而不是那个？

Agent OS Kernel 提供了完整的审计追踪机制，记录 Agent 的完整决策链路。

---

## 八、结语：缺失的内核

1991 年，GNU 项目已经运转了八年。Richard Stallman 和他的追随者们构建了一整套自由软件工具：GCC 编译器、Emacs 编辑器、Bash shell、coreutils……几乎涵盖了操作系统的方方面面。

—— 唯独缺少一个内核。

GNU 自己的内核 Hurd 陷入了无尽的设计争论，迟迟无法完成。所有的工具都已就位，却缺少那个把一切粘合在一起的核心。

就在这时，一个芬兰大学生在邮件列表里发了一个帖子：

> "I'm doing a (free) operating system (just a hobby, won't be big and professional like gnu)…"

他写的那个"业余爱好"，填补了最后一块拼图。GNU 的工具加上 Linux 的内核，构成了我们今天所说的 GNU/Linux —— 云时代的基石。

**2025 年的 Agent 生态，正处在同样的时刻。**

我们有了大量的"工具"：LangChain、CrewAI、AutoGen 等框架解决了任务编排；MCP、Skills 解决了工具调用；PostgreSQL 解决了持久化存储；各种 RAG 方案解决了知识检索；E2B、Firecracker 解决了安全隔离……

**但我们缺少一个新的 "Agent OS Kernel"** —— 一个真正能把这一切粘合起来的操作系统层：统一的上下文调度、可恢复的进程状态、标准化的 I/O 接口、完整的信任基础设施与可观测性。

这个内核也许正躲在某个人的 side project 里，就像 1991 年的 Linux 一样——不起眼，没有引发关注，被作者自己称为 "只是个爱好"。但它将成为未来。

---

## 九、历史的剧本

- **内存管理**将是最复杂的技术战场——谁能让 Context 像虚拟内存一样透明地换入换出，谁就能定义下一代基础设施
- **数据库**是确定性最高的商业机会——PostgreSQL 不仅是存储，更有潜力成为 Runtime
- **进程管理**表面红海，深水无人——当 Agent 成为长期运行的服务，真正的调度和恢复需求才会浮现
- **I/O 的终局**不是新协议，而是 Agent-Native CLI —— 55 年的 Unix 哲学不会被轻易颠覆
- **信任层**将成为企业市场的入场券 —— 沙箱是底线，可观测性才是关键

真正的分水岭不是模型变得更强，而是 **系统能力的补齐** 。这套东西一旦成型，Agent 才会从 "会写代码的玩具" 变成 "可以托付业务的进程"。

---

**Agent OS Kernel 正是为了填补这个缺失的内核而生。**

1980 年代，有人在车库里写 DOS 程序；1990 年代，有人在宿舍里写 Linux 内核。202x 的某个深夜，也许正有人在某个终端里，敲下 Agent OS 的第一行代码。

**谁在构建这些基础设施，谁就在定义下一个时代。**
